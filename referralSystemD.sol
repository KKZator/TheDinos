//SPDX-License-Identifier: MIT
/*
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&&&##&IIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&BP5YP##BBBBP5YYPBIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&GPYJY55BBB#GJJYP5Y&IIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&GBGB?JG#BGGGGB!YP&PY#IIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIBYY#P##775B5PPP#G!?PPJ?5BIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&#5J5#PPGBJYGBBBBGG5Y5PGG5YG#IIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII#BGPG##GPPPPGB#&&&&#PPPPP##PPPG&IIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&#BPPG####GYJJYB#&&#P?JPBB&#GPPP&IIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&BBPPP##&#YYY??JY55YJJJYB&&GPPPP#IIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&BBPGB#&&PJ5JYYJJ77?JJJJY&#GPPPPGIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII##B###B&#JJJ??????????JG&BPPPPP#IIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&#B##BY5B#G#GGYY555GGG5GI&BGGB&IIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&##BBG5JYPBBJ?YPB##B###BP5YP&IIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&&###BBG5??55YY555PP5YJJJYY5YYJJPBBGIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII&&&&BPBBBGP55555JJY5555YYY5PP577J!~75PBB5J5IIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIII&&&###BBBGGPBGPGG5J??JJ555555YJJ77JY55PJ~7!^77~5BY5&IIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIII&##BGGGGPPPPPPPPPBBBGPJ??JJY555JY55J?!7?Y555!:??~YP7YBPPIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIII&#BBGPPPPPPPPPPPPPPPPP#BP555YY55555YY55YJ?YYY555J??7:77!?JYBIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIII&&#GPPPPPPPPPPPPPPPPPPPPBBPYY5555555YYJY55555555YJ~!7?~J7:7YGIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIII&&#BGPPPPPPPPPPPPPPPPPPPPPP#PJJY5555Y?J77?Y5555555YJ7~!~~!?YP&IIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIII&&#BGPPPPPPPPPPPPPPPPPPPPPPPPGB555YY555JJJJJY55YY5G55YYJY55PG#IIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIII&B&#BGPPPPPPPPPGPPPPPPPPPPPPPPPGB5Y?7J555G555555J7?PGJ?YPB#&IIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIB#&#BBPPPPPPPPPPGPPPPPPGGGGGGGGPBB5?7YY55BPY?Y555YYG#5Y5BIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIII&B&&#BBGPPPPPPPGG##BBGPGGB######BBB#P55Y5G#555PP5YYJGGYJ??#IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIII#&##BBBGGPPGGGGGGBB5P#BBBBBB#&&&&&&&GPB&I&B&BY?????JPY??7J55G&IIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIII&GGGPP55YYYYJJJ?5BYGI&&&&&&IIIIIIIIIIIIIIIIBYJ???5YJGPYYY5GYPIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIII&&&&&&&&&&&&&&IIIIIIIIIIIIIIIIIIIIIIIIIIII&#BBB###&IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
Wrtten and deployed by Zator(@Kornelia_989) - kkteam.net*/

import "./ERC721AQueryable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

pragma solidity ^0.8.8;

contract defReferralSystem is ERC721AQueryable, Ownable {
    using EnumerableSet for EnumerableSet.UintSet;

    struct referralInfos {
        uint256 referralCode;
        uint256 timeUsed;
        uint256 secondTimeUsed;
        uint256 thirdTimeUsed;
        uint256 tokenID;
        bool canBeUsed;
    }

    uint256 private randIncrement;
    uint256 public nftPrice = 100 * 10**18;
    uint256 public priceIncrease = 10 * 10**18;
    uint256 private firstNftToMint = 50;
    uint256 private boughtNFT;
    uint256 public firstReferredFee = 25;
    uint256 public secondReferredFee = 5;
    uint256 public thirdReferredFee = 3;
    uint256 public firstWalletFee = 20;
    uint256 public secondWalletFee = 20;
    uint256 public thirdWalletFee = 20;
    uint256 public fourthWalletFee = 7;

    uint256 public idCount;
    uint256 private mintLimit = 2000;
    uint256 public mintedNft;
    uint256 public stepToIncrease = 500;
    address public firstWalletAddress = 0xC1D94461B9619547b5E08766B9ac63CA6d7dcea3; 
    address public secondWalletAddress = 0xFb72b1B6005F099335b3F6196f9d7df092F61677; 
    address public thirdWalletAddress = 0xF6252F29831df3426516F3c01323Be0810560b6a; 
    address public fourthWalletAddress = 0x36a761e6f4Dd2c59dce4A1E0128c35Ec375E9d05;
    address public busdAddress = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; 
    string public uriBase = "https://ipfs.io/ipfs/Qmai6vg3HhRVwtmESKUxq2WykKsNqAbx8NzK3oUfQK7y4B/"; 
    bool public systemActive = false;
    bool public systemActiveKS = true;
    //Nft info
    //id
    EnumerableSet.UintSet private commondIDs;
    EnumerableSet.UintSet private rareIDs;
    EnumerableSet.UintSet private superRareIds;
    //referral infos
    mapping(uint256 => address) public referralToOwner;
    mapping(address => uint256[]) public ownerToReferrals;
    mapping(address => EnumerableSet.UintSet) private ownerToNFT;
    mapping(address => referralInfos[]) public ownerToReferralInfos;
    mapping(uint256 => address) public depositedNftToOwner;
    //nft infos
    mapping(uint256 => uint256) public idGeneratedToUsedReferral;
    mapping(uint256 => uint256) public idToGeneratedReferral;
    mapping(uint256 => uint256) private idToRarity;



    event stepToIncreaseUpdated(uint256 newStepToIncrease);
    event systemActivatedAt(uint256 activationTimestamp);
    constructor() ERC721A("The Dinos", "DNS") {}

    function getNft(uint256 referralCode) external returns (uint256) {
        require(systemActive, "Referral System: System not active yet");
        require(boughtNFT <= mintLimit, "Referral System: cannot mint further NFT");
        require(!isContract(msg.sender), "Referral System: caller cannot be a contract");
        require(referralToOwner[referralCode] != address(0), "Referral System: referral inexistent");
        require(IBEP20(busdAddress).balanceOf(msg.sender) >= nftPrice, "Referral System: not enought balance");
        require(referralToOwner[referralCode] != msg.sender, "ReferralSystem: you cannot buy with your own referral code");
        address referralOwner = referralToOwner[referralCode];
        (referralInfos memory refInf, uint256 idx) = getReferralInfos(referralOwner, referralCode);
        require(ownerToReferralInfos[referralOwner][idx].timeUsed + 1 < 11, "ReferralSystem: used referral code expired");
        require(refInf.canBeUsed, "ReferralSystem: the referral cannot be used at the moment");
        if (ownerToReferralInfos[referralOwner][idx].timeUsed + 1 == 10) {
            ownerToReferralInfos[referralOwner][idx].canBeUsed = false;
        }
        ownerToReferralInfos[referralOwner][idx].timeUsed++;
        address firstReferred = referralToOwner[referralCode];

        bool success = IBEP20(busdAddress).transferFrom(msg.sender, firstReferred, ((nftPrice * firstReferredFee) / 100)); //25%
        require(success, "Referral System: transfer to the first referred failed");
        bool success6 = IBEP20(busdAddress).transferFrom(msg.sender, firstWalletAddress, ((nftPrice * firstWalletFee) / 100)); //20%
        require(success6, "Referral System: transfer to the first wallet failed");
        bool success7 = IBEP20(busdAddress).transferFrom(msg.sender, secondWalletAddress, ((nftPrice * secondWalletFee) / 100)); //20%
        require(success7, "Referral System: transfer to the second wallet failed");
        bool success8 = IBEP20(busdAddress).transferFrom(msg.sender, thirdWalletAddress, ((nftPrice * thirdWalletFee) / 100)); // 20%
        require(success8, "Referral System: tansfer to the third wallet failed");
        bool success9 = IBEP20(busdAddress).transferFrom(msg.sender, fourthWalletAddress, ((nftPrice * fourthWalletFee) / 100)); //7%
        require(success9, "Referral System: transfer to the fourth wallet failed");
        uint256 firstReferredTokenId = refInf.tokenID;

        if (idGeneratedToUsedReferral[firstReferredTokenId] != 0) {
            //if 2nd referred
            uint256 secondLevelReferral = idGeneratedToUsedReferral[firstReferredTokenId];
            address secondReferred = referralToOwner[secondLevelReferral];
            (, uint256 ind) = getReferralInfos(secondReferred, secondLevelReferral);
            ownerToReferralInfos[secondReferred][ind].secondTimeUsed++;
            bool success2 = IBEP20(busdAddress).transferFrom(msg.sender, secondReferred, ((nftPrice * secondReferredFee) / 100)); //5%
            require(success2, "Referral System: transfer to the second referral owner failed");
            (referralInfos memory refInf2, ) = getReferralInfos(secondReferred, secondLevelReferral);
            uint256 secondReferredTokenId = refInf2.tokenID;

            if (idGeneratedToUsedReferral[secondReferredTokenId] != 0) {
                //if 3rd referred
                uint256 thirdLevelReferral = idGeneratedToUsedReferral[secondReferredTokenId];
                address thirdReferred = referralToOwner[thirdLevelReferral];
                (, uint256 idx3) = getReferralInfos(thirdReferred, thirdLevelReferral);
                ownerToReferralInfos[thirdReferred][idx3].thirdTimeUsed++;
                bool success3 = IBEP20(busdAddress).transferFrom(
                    msg.sender,
                    thirdReferred,
                    ((nftPrice * thirdReferredFee) / 100) //3%
                );
                require(success3, "Referral System: transfer to the third referral owner failed");
            } else {
                //not 3rd referred
                bool success4 = IBEP20(busdAddress).transferFrom(
                    msg.sender,
                    fourthWalletAddress,
                    (nftPrice * thirdReferredFee) / 100 //3%
                );
                require(success4, "Referral System: transfer of the third percentage to the wallet failed"); //3%
            }
        } else {
            //if not 2nd referred
            bool success5 = IBEP20(busdAddress).transferFrom(
                msg.sender,
                fourthWalletAddress,
                ((nftPrice *( secondReferredFee + thirdReferredFee)) / 100)
            ); //5+3%
            require(success5, "Referral System: transfer of the second and third percentage to the wallet failed");
        }
        uint256 rarity = selectRarity();
        uint256 tokenId = selectRandomID(rarity);
        boughtNFT += 1;
        if (boughtNFT % stepToIncrease == 0) {
            nftPrice += priceIncrease;
        }
        this.transferFrom(address(this), msg.sender, tokenId);
        EnumerableSet.remove(ownerToNFT[address(this)], tokenId);
        EnumerableSet.add(ownerToNFT[msg.sender], tokenId);
        idGeneratedToUsedReferral[tokenId] = referralCode;
        EnumerableSet.add(ownerToNFT[msg.sender], tokenId);
        return tokenId;
    }

    
    function generateReferralCode(uint256 tokenID) external returns (uint256) {
        require(balanceOf(msg.sender) > 0, "Referral System: You have not NFTs to deposit");
        require(msg.sender == ownerOf(tokenID), "Referral System: You are not the owner of the NFT");
        require(idToGeneratedReferral[tokenID] == 0, "Referral System: the NFT already has its referral number");
        if (tokenID < firstNftToMint + 1) {
            //se e uno dei primi il suo direct referred è il wallet d
            idGeneratedToUsedReferral[tokenID] = 0;
        }
        uint256 referralNumber = moreRand() % 1000000;
        require(referralToOwner[referralNumber] == address(0), "Referral System: referral already exists");
        referralToOwner[referralNumber] = msg.sender;
        ownerToReferrals[msg.sender].push(referralNumber);
        ownerToReferralInfos[msg.sender].push(referralInfos(referralNumber, 0, 0, 0, tokenID, true));
        depositedNftToOwner[tokenID] = msg.sender;
        idToGeneratedReferral[tokenID] = referralNumber;
        (referralInfos memory refInf, uint256 idx) = getReferralInfosByTokenId(msg.sender, tokenID);
        ownerToReferralInfos[msg.sender][idx].canBeUsed = true;
        refInf.canBeUsed = true;
        transferFrom(msg.sender, address(this), tokenID);
        return referralNumber;
    }

    function depositNft(uint256 tokenId) external {
        require(idToGeneratedReferral[tokenId] != 0, "Referral System: this NFT has no referral associated");
        (referralInfos memory refInf, uint256 idx) = getReferralInfosByTokenId(msg.sender, tokenId);
        ownerToReferralInfos[msg.sender][idx].canBeUsed = true;
        refInf.canBeUsed = true;
        depositedNftToOwner[tokenId] = msg.sender;
        transferFrom(msg.sender, address(this), tokenId);
    }

    function withdrawNft(uint256 tokenId) external {
        require(depositedNftToOwner[tokenId] == msg.sender, "Referral System: You are not the owner of the NFT");
        require(depositedNftToOwner[tokenId] == msg.sender, "Referral System: You have not deposited the NFT");
        (referralInfos memory refInfo, uint256 idx) = getReferralInfosByTokenId(msg.sender, tokenId);
        require(refInfo.canBeUsed, "Referral System: You cannot withdraw the NFT");
        ownerToReferralInfos[msg.sender][idx].canBeUsed = false;
        refInfo.canBeUsed = false;
        this.transferFrom(address(this), msg.sender, tokenId);
        delete depositedNftToOwner[tokenId];
    }

    //Mint functions
    //1 == common
    //2 == rare
    //3 == superRare
    function mintSupply(uint256 rarity, uint256 amount) external onlyOwner {
        require(rarity > 0 && rarity < 4, "Referral System: The inserted rarity does not exist");
        if (rarity == 1) {
            mintCommonNft(amount);
        } else if (rarity == 2) {
            mintRareNft(amount);
        } else {
            mintSuperareNft(amount);
        } 
    }

    function mintCommonNft(uint256 amount) private {
        super._mint(address(this), amount);
        for (uint256 i = idCount; i < idCount + amount; i++) {
            EnumerableSet.add(commondIDs, i);
            idToRarity[i] = 1;
        }
        mintedNft += amount;
        idCount += amount;
    }

    function mintRareNft(uint256 amount) private {
        super._mint(address(this), amount);
        for (uint256 i = idCount; i < idCount + amount; i++) {
            EnumerableSet.add(rareIDs, i);
            idToRarity[i] = 2;
        }
        mintedNft += amount;
        idCount += amount;
    }

    function mintSuperareNft(uint256 amount) private {
        super._mint(address(this), amount);
        for (uint256 i = idCount; i < idCount + amount; i++) {
            EnumerableSet.add(superRareIds, i);
            idToRarity[i] = 3;
        }
        mintedNft += amount;
        idCount += amount;
    }


    function adminMint(
        uint256 rarity,
        uint256 amount,
        address receiver
    ) external onlyOwner {
        require(rarity > 0 && rarity < 5, "Referral System: The inserted rarity does not exist");
        require(mintedNft < firstNftToMint + 1, "Referral System: initial supply minted, this function cannot be called");

        if (rarity == 1) {
            super._mint(receiver, amount);
            for (uint256 i = idCount; i < idCount + amount; i++) {
                EnumerableSet.add(ownerToNFT[receiver], i);
                idToRarity[i] = 1;
            }
        }
        if (rarity == 2) {
            super._mint(receiver, amount);
            for (uint256 i = idCount; i < idCount + amount; i++) {
                EnumerableSet.add(ownerToNFT[receiver], i);
                idToRarity[i] = 2;
            }
        }
        if (rarity == 3) {
            super._mint(receiver, amount);
            for (uint256 i = idCount; i < idCount + amount; i++) {
                EnumerableSet.add(ownerToNFT[receiver], i);
                idToRarity[i] = 3;
            }
        }
        mintedNft += amount;
        idCount += amount;
    }

    function selectRarity() private returns (uint256) {
        uint256 rarity;
        uint256 tempRarity = randrange(1, 100);
        if (tempRarity < 81) {
            rarity = 1; //comune
        } else if (tempRarity > 80 && tempRarity < 96) {
            rarity = 2; //raro
        } else {
            rarity = 3; //super raro
        }
        return rarity;
    }

    function selectRandomID(uint256 rarity) private returns (uint256) {
        require(rarity < 4 && rarity > 0, "Referral System: rarity inexistent");
        uint256 tokenId;
        if (rarity == 1) {
            uint256 leftoverNft = EnumerableSet.length(commondIDs);
            uint256 randomIdx = randrange(0, leftoverNft);
            tokenId = EnumerableSet.at(commondIDs, randomIdx);
            EnumerableSet.remove(commondIDs, tokenId);
            return tokenId;
        } else if (rarity == 2) {
            uint256 leftoverNft = EnumerableSet.length(rareIDs);
            uint256 randomIdx = randrange(0, leftoverNft);
            tokenId = EnumerableSet.at(rareIDs, randomIdx);
            EnumerableSet.remove(rareIDs, tokenId);
            return tokenId;
        } else {
            uint256 leftoverNft = EnumerableSet.length(superRareIds);
            uint256 randomIdx = randrange(0, leftoverNft);
            tokenId = EnumerableSet.at(superRareIds, randomIdx);
            EnumerableSet.remove(superRareIds, tokenId);
            return tokenId;
        }
    }

    //set
    function setMintLimit(uint256 newLimit) external onlyOwner {
        mintLimit = newLimit;
    }

    function activateSystem() external onlyOwner{
        require(systemActiveKS, "Referral System: System status cannot be further modified");
        systemActive = true;
        systemActiveKS = false;
        emit systemActivatedAt(block.timestamp);
    }

    //Randomness
    function randint() private returns (uint256) {
        uint256 asd = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % 420420;
        if (randIncrement > asd) {
            randIncrement += 69;
        } else {
            randIncrement += 420;
        }
        return
            uint256(
                keccak256(abi.encodePacked(block.timestamp / randIncrement, (block.timestamp * asd) / (randIncrement * asd)))
            );
    }

    function moreRand() private returns (uint256) {
        if (randIncrement > randint()) {
            randIncrement -= 420;
        } else {
            randIncrement += 69;
        }
        return uint256(keccak256(abi.encodePacked(randint() / (randIncrement * 6), randint() / (randIncrement * 9))));
    }

    function randrange(uint256 a, uint256 b) private returns (uint256) {
        require(b > 0, "lenght list tokenID avalable is 0");
        return a + (moreRand() % b);
    }

    function isContract(address _addr) private view returns (bool isContractz) {
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }

    //get

    function getReferralList(address target) external view returns (uint256[] memory) {
        uint256 length = ownerToReferrals[target].length;
        uint256[] memory referralList = new uint256[](length);
        for (uint256 i = 0; i < length; i++) {
            referralList[i] = ownerToReferrals[target][i];
        }
        return referralList;
    }

    function getOwnerToReferralIndex(address target, uint256 referralNumber) public view returns (uint256) {
        uint256[] memory tempReferralList = ownerToReferrals[target];
        for (uint256 i = 0; i < tempReferralList.length; i++) {
            if (tempReferralList[i] == referralNumber) {
                return i;
            }
        }
    }

    function getReferralInfosList(address target) external view returns (referralInfos[] memory) {
        uint256 length = ownerToReferralInfos[target].length;
        referralInfos[] memory refList = new referralInfos[](length);
        for (uint256 i = 0; i < length; i++) {
            refList[i] = ownerToReferralInfos[target][i];
        }
        return refList;
    }

    function getReferralInfos(address target, uint256 referral) public view returns (referralInfos memory, uint256) {
        referralInfos[] memory tempInfos = ownerToReferralInfos[target];
        for (uint256 i = 0; i < tempInfos.length; i++) {
            if (tempInfos[i].referralCode == referral) {
                return (tempInfos[i], i);
            }
        }
    }

    function getReferralInfosByTokenId(address target, uint256 tokenId) public view returns (referralInfos memory, uint256) {
        referralInfos[] memory tempInfos = ownerToReferralInfos[target];
        for (uint256 i = 0; i < tempInfos.length; i++) {
            if (tempInfos[i].tokenID == tokenId) {
                return (tempInfos[i], i);
            }
        }
    }

    function getTokensOfOwner(address target) public view returns (uint256[] memory) {
        uint256 setLength = EnumerableSet.length(ownerToNFT[target]);
        uint256[] memory ids = new uint256[](setLength);
        for (uint256 i = 0; i < setLength; i++) {
            ids[i] = EnumerableSet.at(ownerToNFT[target], i);
        }
        return ids;
    }

    function getReferralLine(uint256 tokenId) external view returns (address[] memory) {
        address[] memory referralLine = new address[](3);

        if (idGeneratedToUsedReferral[tokenId] != 0) {
            uint256 firstReferral = idGeneratedToUsedReferral[tokenId];
            address firstReferred = referralToOwner[firstReferral];
            referralLine[0] = firstReferred;
            (referralInfos memory refInf, ) = getReferralInfos(firstReferred, firstReferral);
            uint256 firstReferredTokenId = refInf.tokenID;

            if (idGeneratedToUsedReferral[firstReferredTokenId] != 0) {
                uint256 secondLevelReferral = idGeneratedToUsedReferral[firstReferredTokenId];
                address secondReferred = referralToOwner[secondLevelReferral];
                referralLine[1] = secondReferred;
                (refInf, ) = getReferralInfos(secondReferred, secondLevelReferral);
                uint256 secondReferredTokenId = refInf.tokenID;

                if (idGeneratedToUsedReferral[secondReferredTokenId] != 0) {
                    uint256 thirdLevelReferral = idGeneratedToUsedReferral[secondReferredTokenId];
                    address thirdReferred = referralToOwner[thirdLevelReferral];
                    referralLine[2] = thirdReferred;
                } else {
                    referralLine[2] = address(this);
                }
            } else {
                referralLine[1] = address(this);
                referralLine[2] = address(this);
            }
        } else {
            referralLine[0] = address(this);
            referralLine[1] = address(this);
            referralLine[2] = address(this);
        }
        return referralLine;
    }

    function getOwnerToNFT(address target) external view returns (uint256[] memory) {
        uint256 nftOwned = EnumerableSet.length(ownerToNFT[target]);
        uint256[] memory idList = new uint256[](nftOwned);
        for (uint256 i = 0; i < nftOwned; i++) {
            idList[i] = EnumerableSet.at(ownerToNFT[target], i);
        }
        return idList;
    }

    function getTokenRarity(uint256 tokenId) external view returns(uint256 rarity){
        if(EnumerableSet.contains(commondIDs, tokenId)){
            return 1;
        } else if(EnumerableSet.contains(rareIDs, tokenId)){
            return 2;
        } else if(EnumerableSet.contains(superRareIds, tokenId)){
            return 3;
        }
    }

    //override

    function supportsInterface(bytes4 interfaceId) public view override(ERC721A, IERC721A) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function _burn(uint256 tokenId) internal override(ERC721A) {
        super._burn(tokenId);
    }

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public payable override(ERC721A, IERC721A) {
        if (to != address(this)) {
            uint256 length = ownerToReferrals[from].length;
            uint256 tempRef = idToGeneratedReferral[tokenId];
            if (length > 1) {
                uint256 idx = getOwnerToReferralIndex(from, tempRef);

                
                ownerToReferrals[from][idx] = ownerToReferrals[from][length - 1];
                ownerToReferrals[from].pop();               
                length = ownerToReferralInfos[from].length;
                (referralInfos memory refInf, uint256 ind) = getReferralInfosByTokenId(from, tokenId);
                ownerToReferralInfos[from][ind] = ownerToReferralInfos[from][length - 1];
                ownerToReferralInfos[from].pop();

                //updating to info
                referralToOwner[tempRef] = to;
                ownerToReferrals[to].push(tempRef);
                ownerToReferralInfos[to].push(refInf);
            } else if (length > 0) {
                //delete referralToOwner[tempRef];
                ownerToReferrals[from].pop();
                (referralInfos memory refInf, ) = getReferralInfosByTokenId(from, tokenId);
                ownerToReferralInfos[from].pop();

                referralToOwner[tempRef] = to;
                ownerToReferrals[to].push(tempRef);
                ownerToReferralInfos[to].push(refInf);
            }
            EnumerableSet.remove(ownerToNFT[from], tokenId);
            EnumerableSet.add(ownerToNFT[to], tokenId);
        }
        super.transferFrom(from, to, tokenId);
    }

    function tokenURI(uint256 tokenId) public view virtual override(ERC721A, IERC721A) returns (string memory) {
        return string.concat(string.concat(uriBase, Strings.toString(tokenId + 1)), ".json");
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return uriBase;
    }

    function setBaseUri(string memory newBase) external onlyOwner {
        uriBase = newBase;
    }
}

interface IBEP20 {
    function allowance(address _owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
